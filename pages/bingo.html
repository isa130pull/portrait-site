<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bingo Maker | かわぐち（isa130pull）</title>
  <meta name="description" content="3×3のビンゴカードを作成・共有できるツール。編集モード・チェックモード搭載。画像保存、リンク共有に対応。" />
  <link rel="canonical" href="https://isa130pull.github.io/portrait-site/pages/bingo.html" />
  <style>
    :root{
      --bg: #0b0c0f;
      --fg: #e8eaed;
      --muted: #a1a7b3;
      --accent: #6ee7ff;
      --card: #14161a;
      --border: #1f2329;
      --maxw: 1024px;
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#ffffff; --fg:#111318; --muted:#5a6472; --card:#f7f8fa; --border:#e5e7eb; --accent:#0ea5e9; }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic UI", sans-serif}
    .wrap{max-width:var(--maxw);margin:0 auto;padding:24px}
    header{padding:24px 0;border-bottom:1px solid var(--border);margin-bottom:24px}
    .back-link{display:inline-block;margin-bottom:16px;padding:8px 16px;border:1px solid var(--border);border-radius:8px;color:var(--fg);text-decoration:none}
    .back-link:hover{border-color:var(--accent);text-decoration:none}
    h1{font-size:clamp(24px, 4vw, 32px);margin:0;font-weight:700;letter-spacing:.02em}
    .lead{color:var(--muted);margin:16px 0;line-height:1.6}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:20px;margin-bottom:24px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .row > *{margin:4px 0}
    .seg{display:inline-flex;background:var(--card);border:1px solid var(--border);border-radius:999px;overflow:hidden}
    .seg input{display:none}
    .seg label{padding:8px 16px;color:var(--muted);cursor:pointer;font-size:14px}
    .seg input:checked + label{background:var(--accent);color:var(--bg);font-weight:600}
    button, .ghost{appearance:none;border:1px solid var(--border);background:var(--card);color:var(--fg);padding:10px 16px;border-radius:8px;cursor:pointer;font-size:14px;font-weight:500;transition:border-color .2s}
    button:hover{border-color:var(--accent)}
    button.primary{background:var(--accent);color:var(--bg);border-color:var(--accent);font-weight:600}
    .ghost{color:var(--muted)}
    .grid{display:grid;gap:8px;margin-top:20px}
    .cell{background:var(--bg);border:1px solid var(--border);border-radius:12px;position:relative;overflow:hidden;transition:all .2s ease}
    .cell.filled{background:color-mix(in oklab, var(--accent), transparent 95%);border-color:color-mix(in oklab, var(--accent), transparent 70%)}
    .cell.focused{border-color:var(--accent);box-shadow:0 0 0 2px color-mix(in oklab, var(--accent), transparent 85%)}
    .cell input{width:100%;height:100%;background:transparent;border:0;outline:none;color:var(--fg);padding:10px;text-align:center;font-weight:600;font-size:15px}
    .mark{position:absolute;inset:0;background:rgba(46, 204, 112, 0.15);border:2px dashed #2ecc70;border-radius:10px;opacity:0;transition:.12s ease}
    .cell.marked .mark{opacity:1}
    .cell .tick{position:absolute;right:8px;top:8px;font-size:14px;color:#2ecc70;opacity:.9}
    .footer{display:flex;gap:8px;justify-content:space-between;align-items:center;margin-top:16px;color:var(--muted);font-size:13px}
    .toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:var(--card);color:var(--fg);border:1px solid var(--border);padding:12px 18px;border-radius:10px;opacity:0;pointer-events:none;transition:.2s;box-shadow:0 4px 12px rgba(0,0,0,.3)}
    .toast.show{opacity:1}
    canvas{display:none}
    footer{margin-top:64px;padding:24px 0;border-top:1px solid var(--border);color:var(--muted);font-size:14px;text-align:center}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <a href="../index.html" class="back-link">← トップページに戻る</a>
    <h1>🎯 Bingo Maker</h1>
    <p class="lead">3×3のビンゴカードを作成・共有できるツールです。編集モードでマスを入力し、チェックモードでビンゴを楽しめます。</p>
  </header>

  <section class="card">
    <div class="form-group" style="margin-bottom:20px">
      <label for="title" style="display:block;font-weight:600;margin-bottom:8px;font-size:15px">ビンゴタイトル</label>
      <input type="text" id="title" placeholder="例：自己紹介ビンゴ" style="width:100%;padding:10px 14px;background:var(--bg);border:1px solid var(--border);border-radius:8px;color:var(--fg);font-size:15px;font-family:inherit">
    </div>

    <div class="row" style="justify-content:flex-end;margin-bottom:16px">
      <div class="seg" role="tablist" aria-label="Mode">
        <input type="radio" name="mode" id="edit" checked><label for="edit">編集</label>
        <input type="radio" name="mode" id="play"><label for="play">チェック</label>
      </div>
    </div>

    <div id="board" class="grid"></div>

    <div style="margin-top:20px;display:flex;gap:12px;flex-wrap:wrap;justify-content:space-between;align-items:center">
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="resetBtn" class="ghost">リセット</button>
        <button id="exportPng" class="primary">画像保存</button>
        <button id="shareLink">リンク共有</button>
      </div>
      <small id="status" style="color:var(--muted)"></small>
    </div>
  </section>
</div>

<div class="toast" id="toast"></div>
<canvas id="off"></canvas>

<footer>
  <p>© <span id="y"></span> かわぐち (isa130pull)</p>
</footer>

<script>
// ===== Utilities =====
const $ = (q)=>document.querySelector(q);
const boardEl = $('#board');
const statusEl = $('#status');
const titleInput = $('#title');
const toast = $('#toast');
const off = $('#off');

function showToast(msg){
  toast.textContent = msg; toast.classList.add('show');
  setTimeout(()=>toast.classList.remove('show'), 1600);
}

// UTF-8 safe base64 for shorter share links
const b64u = {
  enc: (str)=>{
    const u8 = new TextEncoder().encode(str);
    let bin = ''; for (const b of u8) bin += String.fromCharCode(b);
    return btoa(bin).replaceAll('+','-').replaceAll('/','_').replace(/=+$/,'');
  },
  dec: (s)=>{
    s = s.replaceAll('-','+').replaceAll('_','/');
    const pad = s.length % 4 === 0 ? '' : '='.repeat(4 - (s.length % 4));
    const bin = atob(s + pad);
    const u8 = new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
    return new TextDecoder().decode(u8);
  }
};

// ===== State =====
const defaultTitle = 'ビンゴ';
const BOARD_SIZE = 3;

let state = {
  id: null,
  cells: Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill('')),
  marked: Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(false)),
  title: defaultTitle,
  version: 1,
  mode: 'edit',
};

function setMode(m){
  state.mode = m;
  render();
  saveLocal();

  // 編集モードに切り替えたら最初の空白マスにフォーカス
  if(m === 'edit') {
    setTimeout(()=> focusFirstEmptyCell(), 100);
  }
}

function resetBoard(){
  if(!confirm('ビンゴカードをリセットしますか？\n（入力内容が削除されます）')) return;
  state.cells = Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(''));
  state.marked = Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(false));
  state.title = defaultTitle;
  titleInput.value = defaultTitle;
  render();
  saveLocal();
  showToast('リセットしました');
}

function serialize(){
  if(!state.id) state.id = crypto.randomUUID();
  return JSON.stringify({
    id: state.id,
    cells: state.cells,
    marked: state.marked,
    title: state.title,
    version: state.version
  });
}

function loadFrom(obj){
  state.id = obj.id || null;
  state.cells = obj.cells;
  state.marked = obj.marked;
  state.title = obj.title || defaultTitle;
  state.version = obj.version || 1;
  titleInput.value = state.title;
  render();
}

// ===== UI =====
function render(){
  const n = BOARD_SIZE;
  boardEl.style.gridTemplateColumns = `repeat(${n},1fr)`;
  boardEl.innerHTML = '';

  for(let r=0;r<n;r++){
    for(let c=0;c<n;c++){
      const cell = document.createElement('div');

      // 入力済みかどうかの判定
      const isFilled = state.cells[r][c] && state.cells[r][c].trim() !== '';
      cell.className = 'cell'
        + (state.marked[r][c] ? ' marked' : '')
        + (isFilled ? ' filled' : '');

      cell.dataset.r=r; cell.dataset.c=c;

      const input = document.createElement('input');
      input.value = state.cells[r][c] || '';
      input.inputMode = 'text';
      input.maxLength = 40;
      input.dataset.index = r * n + c;  // インデックスを保存

      // IME変換中かどうかのフラグ
      let isComposing = false;

      input.addEventListener('compositionstart', ()=>{
        isComposing = true;
      });

      input.addEventListener('compositionend', ()=>{
        isComposing = false;
      });

      input.addEventListener('input', (e)=>{
        state.cells[r][c] = e.target.value;
        saveLocal();
        updateProgress();
        // 入力済みクラスの更新
        if(e.target.value.trim()) {
          cell.classList.add('filled');
        } else {
          cell.classList.remove('filled');
        }
      });

      // Enterキーで次のマスへ移動（IME変換中は除外）
      input.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' && !isComposing) {
          e.preventDefault();
          focusNextCell(input.dataset.index);
        }
      });

      // フォーカス時のスタイル
      input.addEventListener('focus', ()=>{
        cell.classList.add('focused');
      });

      input.addEventListener('blur', ()=>{
        cell.classList.remove('focused');
      });

      if(state.mode==='play') input.disabled = true; else input.disabled = false;

      const mark = document.createElement('div');
      mark.className = 'mark';
      const tick = document.createElement('div'); tick.className='tick'; tick.textContent='✓';
      mark.appendChild(tick);

      cell.appendChild(input); cell.appendChild(mark);

      cell.addEventListener('click', (e)=>{
        if(state.mode === 'edit') {
          // 編集モード：inputにフォーカス
          input.focus();
        } else {
          // チェックモード：マークのトグル
          state.marked[r][c] = !state.marked[r][c];
          saveLocal();
          render();
        }
      });
      boardEl.appendChild(cell);
    }
  }

  updateProgress();
}

// ===== 入力支援機能 =====

// 次のマスにフォーカスを移動
function focusNextCell(currentIndex){
  const nextIndex = parseInt(currentIndex) + 1;
  const totalCells = BOARD_SIZE * BOARD_SIZE;

  if(nextIndex < totalCells) {
    const inputs = boardEl.querySelectorAll('input');
    if(inputs[nextIndex]) {
      inputs[nextIndex].focus();
    }
  } else {
    // 最後のマスの場合はフォーカスを外す
    document.activeElement.blur();
    showToast('入力完了！');
  }
}

// 最初の空白マスにフォーカス
function focusFirstEmptyCell(){
  if(state.mode !== 'edit') return;

  for(let r=0; r<BOARD_SIZE; r++){
    for(let c=0; c<BOARD_SIZE; c++){
      if(!state.cells[r][c] || state.cells[r][c].trim() === ''){
        const index = r * BOARD_SIZE + c;
        const inputs = boardEl.querySelectorAll('input');
        if(inputs[index]) {
          inputs[index].focus();
          return;
        }
      }
    }
  }

  // すべて入力済みの場合は最初のマスにフォーカス
  const inputs = boardEl.querySelectorAll('input');
  if(inputs[0]) inputs[0].focus();
}

// 入力進捗を更新
function updateProgress(){
  let filledCount = 0;
  const totalCells = BOARD_SIZE * BOARD_SIZE;

  for(let r=0; r<BOARD_SIZE; r++){
    for(let c=0; c<BOARD_SIZE; c++){
      if(state.cells[r][c] && state.cells[r][c].trim() !== ''){
        filledCount++;
      }
    }
  }

  const progressText = `${filledCount}/${totalCells} 入力済み`;
  statusEl.textContent = state.mode === 'edit'
    ? `${progressText} | モード: 編集`
    : `モード: チェック`;
}

// ===== Local persistence =====
const LS_KEY = 'bingo.saved.v1';
function saveLocal(){ try{ localStorage.setItem(LS_KEY, serialize()); }catch(e){} }
function loadLocal(){ try{ const j = localStorage.getItem(LS_KEY); if(j){ loadFrom(JSON.parse(j)); } }catch(e){} }

// ===== PNG export (Canvas 2D) =====
function exportPNG(){
  const px = 2048; const topMargin = 180; const sideMargin = 80; const gridStroke = 8;
  const n = BOARD_SIZE; const gridSize = px - sideMargin*2; const cell = gridSize / n;
  const gridTop = topMargin;

  off.width = px; off.height = px + topMargin; const ctx = off.getContext('2d');
  ctx.clearRect(0,0,px,px+topMargin);
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,px,px+topMargin);

  // タイトル描画
  const title = state.title || defaultTitle;
  ctx.fillStyle = '#111';
  ctx.font = 'bold 80px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(title, px/2, topMargin/2);

  // グリッド描画
  ctx.strokeStyle = '#222'; ctx.lineWidth = gridStroke; ctx.lineCap='square';
  for(let i=0;i<=n;i++){
    const p = sideMargin + i*cell;
    ctx.beginPath(); ctx.moveTo(sideMargin, gridTop + i*cell); ctx.lineTo(sideMargin+gridSize, gridTop + i*cell); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p, gridTop); ctx.lineTo(p, gridTop+gridSize); ctx.stroke();
  }

  // セル描画
  ctx.fillStyle = '#111';
  for(let r=0;r<n;r++){
    for(let c=0;c<n;c++){
      const x = sideMargin + c*cell, y = gridTop + r*cell;
      if(state.marked[r][c]){ ctx.fillStyle = 'rgba(46, 204, 112, 0.2)'; ctx.fillRect(x,y,cell,cell); ctx.fillStyle = '#111'; }
      const label = (state.cells[r][c]||'').trim();
      if(!label) continue;
      drawWrappedText(ctx, label, x, y, cell, cell, 64);
    }
  }

  off.toBlob(async (blob)=>{
    const fileName = `${state.title || 'bingo'}_${n}x${n}.png`.replace(/[\/\\?%*:|"<>]/g, '-');
    const file = new File([blob], fileName, {type:'image/png'});
    if(navigator.canShare && navigator.canShare({files:[file]})){
      try{ await navigator.share({files:[file], title:state.title}); }catch(e){
        downloadBlob(blob, fileName);
      }
    }else{
      downloadBlob(blob, fileName);
    }
  }, 'image/png', 1.0);
}

function drawWrappedText(ctx, text, x, y, w, h, baseSize){
  // Adaptive font size & wrapping
  let fontSize = baseSize; ctx.textBaseline = 'middle'; ctx.textAlign='center'; ctx.fillStyle = '#111';
  const words = splitGraphemes(text);
  // Find lines that fit
  function measure(lines){
    ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, \"Noto Sans JP\", sans-serif`;
    let max = 0; for(const line of lines) max = Math.max(max, ctx.measureText(line).width);
    return max;
  }
  let lines = [];
  let cur = '';
  for(const wch of words){
    const next = cur + wch; ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, \"Noto Sans JP\", sans-serif`;
    if(ctx.measureText(next).width > w*0.9 && cur){ lines.push(cur); cur = wch; }
    else cur = next;
  }
  if(cur) lines.push(cur);
  while(lines.length*fontSize*1.2 > h*0.9){ fontSize -= 2; if(fontSize<18) break; }
  while(measure(lines) > w*0.9){ fontSize -= 2; if(fontSize<18) break; }
  const totalH = lines.length*fontSize*1.2; let sy = y + (h-totalH)/2 + fontSize*0.8;
  for(const line of lines){ ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, \"Noto Sans JP\", sans-serif`; ctx.fillText(line, x + w/2, sy); sy += fontSize*1.2; }
}

function splitGraphemes(str){
  // Basic grapheme split incl. Japanese; not full ICU but good enough
  return Array.from(str);
}

function downloadBlob(blob, name){
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  showToast('画像を保存しました');
}

// ===== リンク共有 =====
async function shareLink(){
  const data = serialize();
  const enc = b64u.enc(data);
  const url = location.origin + location.pathname + '#b=' + enc;
  try{
    await navigator.clipboard.writeText(url);
    showToast('リンクをコピーしました');
  }catch(e){
    prompt('このURLをコピーしてください', url);
  }
}

// ===== URL hash load =====
function tryLoadFromURL(){
  if(location.hash.startsWith('#b=')){
    try {
      const enc = location.hash.slice(3);
      const json = b64u.dec(enc);
      const obj = JSON.parse(json);
      loadFrom(obj);
      showToast('リンクから読み込みました');
    } catch(e){ console.warn('URL parse failed', e); }
  }
}

// ===== Events =====
$('#edit').addEventListener('change', ()=> setMode('edit'));
$('#play').addEventListener('change', ()=> setMode('play'));
$('#resetBtn').addEventListener('click', resetBoard);
$('#exportPng').addEventListener('click', exportPNG);
$('#shareLink').addEventListener('click', shareLink);

// タイトル入力の監視
titleInput.addEventListener('input', (e)=>{
  state.title = e.target.value || defaultTitle;
  saveLocal();
});

// ===== Boot =====
loadLocal();
render();
tryLoadFromURL();

// 編集モードの場合、最初の空白マスにフォーカス
setTimeout(()=>{
  if(state.mode === 'edit') {
    focusFirstEmptyCell();
  }
}, 100);

// Footer year
document.getElementById('y').textContent = new Date().getFullYear();
</script>
</body>
</html>
